# Dafny 双端队列 (FixedDeque) 实现

本文档介绍了 `deque.dfy` 中使用 Dafny 语言实现的固定容量双端队列（Fixed-size Deque）的详细信息。

## 1. 数据结构描述

`FixedDeque<T>` 是一个通用的、有界（固定容量）的双端队列。它允许从队列的头部和尾部进行高效的元素添加和移除操作。其核心特性如下：

- **双端操作**: 支持在队列的两端进行 `Push` (添加) 和 `Pop` (移除) 操作。
    - `PushFront` / `PopFront`: 在队列头部添加/移除元素。
    - `PushBack` / `PopBack`: 在队列尾部添加/移除元素。
- **固定容量**: 队列的容量在创建时被指定，并且之后不能改变。任何试图超出其容量的添加操作都将被禁止（由前置条件 `requires Size() < data.Length` 保证）。
- **环形缓冲区**: 底层数据结构是一个固定大小的数组，通过头（`head`）和尾（`tail`）两个指针来实现环形访问。

## 2. 实现思路

该双端队列通过一个数组 `data` 和两个索引 `head` 与 `tail` 来实现，这是一种经典的环形缓冲区（Circular Buffer）设计。

- **`data: array<T>`**: 存储队列元素的底层数组。
- **`head: nat`**: 指向队列中第一个元素的数组索引。
- **`tail: nat`**: 指向队列中最后一个元素之后下一个可用位置的索引。

### 核心机制

- **空队列状态**: 设计了一个特殊的初始状态来表示空队列：`head == data.Length` 且 `tail == 0`。这可以清晰地将“空”与“满”区分开。
- **元素存储**:
    - 当 `head < tail` 时，队列中的元素连续存储在 `data[head..tail]`。
    - 当队列内容“环绕”数组时（即 `head >= tail`），元素被分成两段：`data[head..]` 和 `data[..tail]`。
- **计算大小 (`Size()`)**:
    - 如果 `head < tail`，大小为 `tail - head`。
    - 否则（包括初始空状态和环绕情况），大小为 `tail + data.Length - head`。
- **操作逻辑**:
    - **`PushBack(x)`**: 在 `tail` 位置放入新元素 `x`，然后将 `tail` 向后移动。如果 `tail` 到达数组末尾，则环绕到 `0`。
    - **`PushFront(x)`**: 将 `head` 向前移动（如果为 `0` 则环绕到数组末尾），然后在新的 `head` 位置放入元素 `x`。
    - **`PopBack()`**: 将 `tail` 向前移动，有效地“丢弃”最后一个元素。
    - **`PopFront()`**: 将 `head` 向后移动，有效地“丢弃”第一个元素。
- **满队列状态**: 当 `head == tail`（且不是初始空状态时），表示队列已满。

## 3. 验证思路

Dafny 的形式化验证能力被用来确保此数据结构实现的正确性。验证的核心在于将具体的实现（数组和指针）与一个抽象的数学模型（序列 `seq<T>`）关联起来。

- **`predicate Valid()`**: 这是一个关键的**不变量（Invariant）**，它定义了 `FixedDeque` 任何时刻都必须满足的健康状态。它约束了 `head` 和 `tail` 的值必须在合法范围内。所有对外部可见的方法都必须保持这个不变量。

- **`function ToSeq(): seq<T>`**: 这是连接具体实现和抽象模型的桥梁。它将环形缓冲区中的元素（可能分为两段）转换成一个纯粹的数学序列。这使得我们可以非常清晰地描述每个操作应该产生的效果。

- **方法规约 (Specifications)**:
    - **`requires`**: 定义了调用一个方法前必须满足的**前置条件**。例如，`PushBack` 要求 `Size() < data.Length`，从而防止了缓冲区溢出。
    - **`ensures`**: 定义了方法成功执行后必须满足的**后置条件**。这些后置条件通常通过 `ToSeq()` 来描述。例如：
        - `PushBack(x)` 的后置条件 `ensures ToSeq() == old(ToSeq()) + [x]` 明确指出，操作后的序列等于旧序列尾部追加一个元素 `x`。
        - `PopFront()` 的后置条件 `ensures ToSeq() == old(ToSeq())[1..]` 指出，操作后的序列等于旧序列去掉第一个元素。

- **测试与引理 (`method {:test}` & `lemma`)**:
    - `testStack` 和 `testQueue` 方法通过具体的入队和出队序列，使用 `expect` 语句验证了双端队列可以被正确地用作栈（LIFO）和队列（FIFO）。
    - `testStackUsage` 和 `testQueueUsage` 是更通用的测试，它们被参数化以处理任意类型的序列，并证明了对于任意输入序列，其行为都符合栈和队列的抽象定义。
    - `EmptyIndicies` 和 `FullIndicies` 等引理（lemma）则进一步证明了内部索引状态与队列的抽象状态（空/满）之间的关系。

## 4. 评价

- **优点**:
    - **高度可靠**: 通过 Dafny 的形式化验证，该实现被证明是正确的，没有常见的环形缓冲区 bug（如 off-by-one 错误、错误的空/满判断等）。
    - **逻辑清晰**: 使用 `ToSeq()` 作为抽象模型，使得每个操作的意图和效果都非常清晰，易于理解和推理。
    - **高效**: 所有操作（Push/Pop/Front/Back）都具有 O(1) 的时间复杂度。

- **局限性**:
    - **固定容量**: 这是一个有界的双端队列，无法动态扩容。对于需要存储无限或未知数量元素的场景不适用。
    - **实现细节**: 将 `head == data.Length` 和 `tail == 0` 作为唯一的空状态是一种有效但非典型的设计。在 `PopBack` 和 `PopFront` 中，当队列变空时，需要显式地将索引重置回这个特殊状态，这增加了一点逻辑复杂性。不过，Dafny 的验证确保了这部分逻辑的正确性。
